<!DOCTYPE html> <html lang="en-us"> <head> <link href="https://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> Cameras in OpenGL &middot; Gabe's Blog </title> <link rel="stylesheet" href="/public/css/poole.css"> <link rel="stylesheet" href="/public/css/syntax.css"> <link rel="stylesheet" href="/public/css/hyde.css"> <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"> <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.1/css/all.css" integrity="sha384-O8whS3fhG2OnA5Kas0Y9l3cfpmYjapjI0E4theH4iuMD+pLhbf6JI0jIMfYcK3yZ" crossorigin="anonymous"> <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png"> <link rel="shortcut icon" href="/public/favicon.ico"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> </head> <body class="theme-base-0d"> <div class="sidebar"> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1> <a href="/"> Gabe's Blog </a> </h1> <p class="lead">A site for programmers by a programmer</p> </div> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="/">Home</a> <a class="sidebar-nav-item" href="/about/">About</a> <a class="sidebar-nav-item" href="/projects/">Projects</a> <div class="sidebar-hz-navs"> <a class="sidebar-nav-item" href="https://www.youtube.com/gameswithgabe" target="_blank"><i class="fab fa-youtube"></i></a> <a class="sidebar-nav-item" href="https://github.com/ambrosiogabe" target="_blank"><i class="fab fa-github"></i></a> </div> </nav> <p>&copy; 2022-2023. All rights reserved.</p> </div> </div> <div class="content container"> <div class="post"> <div> <img src="/public/images/openGlCameras/titleImage.jpg"></img> </div> <h1 class="post-title">Cameras in OpenGL</h1> <span class="post-date">16 Apr 2020</span> <p>A feature that almost every game has and uses is a camera. But how is a camera represented in game code? In this blog post I will explain how cameras work in OpenGL, and provide a simple explanation with some visuals of how you can set up a camera.</p> <h2 id="cameras-in-game-development">Cameras in Game Development</h2> <p>Once again, cameras are commonly used in game development to let the player “view” the scene. There are two main types of cameras that you can use, perspective and orthographic, and they are used for 3D games and 2D games respectively. The main difference in these cameras is the way that the player percieves the game world. In a perspective projection, objects that are further away from the camera appear smaller in size, just like in real life. Whereas, in an orthographic projection, objects appear the same no matter the distance from the camera. The image below demonstrates the difference between these projections.</p> <img src="/public/images/openGlCameras/visual1.png" alt="Ortho vs. Projection"/> <p>As you can see, there is no perception of depth in the orthographic projection. This makes it ideal for 2D games, where you want a layered approach to drawing things. Since there is no distortion as objects are placed further away from the camera, you can draw 2D sprites that you want behind other sprites, further back. Think of this the same way layers work in Photoshop.</p> <p>Now, to get a camera set up for your game, there are two things that you will need, the projection matrix, and the view matrix. The projection matrix defines whether or not you have a perspective, or orthographic projection, and how it will map to your game world. The view matrix defines where the camera is in world space, and where it is pointing. We will discuss these in further detail below.</p> <h2 id="the-projection-matrix">The Projection Matrix</h2> <p>The first step that you would want to do to set up your Camera class in OpenGL, is define your projection matrix. Once again, this is simply setting up a mathematical function that will make your objects either have depth, or not have depth. The example I will show uses JOML, but this will translate very similarly to other Math libraries such as GLM.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Matrix4f</span> <span class="n">perspectiveProjection</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Matrix4f</span><span class="o">().</span><span class="na">identity</span><span class="o">();</span>
<span class="nc">Matrix4f</span> <span class="n">orthoProjection</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Matrix4f</span><span class="o">().</span><span class="na">identity</span><span class="o">();</span>

<span class="n">perspectiveProjection</span> <span class="o">=</span> <span class="n">perspectiveProjection</span><span class="o">.</span><span class="na">perspective</span><span class="o">(</span><span class="n">fov</span><span class="o">,</span>
    <span class="n">aspectRatio</span><span class="o">,</span> <span class="mf">0.1f</span><span class="o">,</span> <span class="mf">100000.0f</span><span class="o">);</span>

<span class="n">orthoProjection</span><span class="o">.</span><span class="na">ortho</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1920</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mf">1080.0f</span><span class="o">,</span> <span class="mf">0.5f</span><span class="o">,</span> <span class="mf">100.0f</span><span class="o">);</span>
</code></pre></div></div> <p>This bit of code sets up two matrices that will define this camera’s projection matrix. I have listed an example that shows how you would set up a perspective matrix, and an orthographic matrix so you can see the differences.</p> <p>The documentation that JOML provides for these two functions are listed <a href="https://joml-ci.github.io/JOML/apidocs/org/joml/Matrix4f.html#perspective-float-float-float-float-">here</a> for the perspective function and <a href="https://joml-ci.github.io/JOML/apidocs/org/joml/Matrix4f.html#ortho-float-float-float-float-float-float-">here</a> for the ortho function. What you can see is that each of them take in a different set of parameters. Let’s go through each of the parameters and see what the math library is using to set up the Matrices.</p> <h4 id="matrix4fperspective">Matrix4f.perspective()</h4> <p>This function takes in 4 floats, they are documented as <code class="language-plaintext highlighter-rouge">fovy</code>, <code class="language-plaintext highlighter-rouge">aspect</code>, <code class="language-plaintext highlighter-rouge">zNear</code> and <code class="language-plaintext highlighter-rouge">zFar</code> respectively. Each of these is used to build an appropriate perspective. The <code class="language-plaintext highlighter-rouge">fovy</code> is used to define the <em>field-of-view</em> in degrees, which basically defines how warped the perspective is. The higher this number is, the more of a fish-bowl look your game will have. A good number for this is typically 45, because that’s close to what we see in real life.</p> <p>The <code class="language-plaintext highlighter-rouge">aspect</code> is the aspect ratio you want your camera to have, this will typically contain the same aspect as the player’s window, so 16:9 for an HD monitor, or 4:3 for a tablet, etc. The last values are the <code class="language-plaintext highlighter-rouge">zNear</code> and <code class="language-plaintext highlighter-rouge">zFar</code> clipping planes. These values determine how close an object can be to the camera before disappearing (<code class="language-plaintext highlighter-rouge">zNear</code>) and how far away an object has to be from the camera before disappearing (<code class="language-plaintext highlighter-rouge">zFar</code>). As you can see, I chose 0.5 and 100000.0 for these values. I chose these because 0.5 is the closest I want my camera to ever get to an object, and you can typically set the <code class="language-plaintext highlighter-rouge">zFar</code> to an arbitrarily large number without any performance penalties for reasons that are beyond the scope of this article.</p> <h4 id="matrix4fortho">Matrix4f.ortho()</h4> <p>This function takes 6 floats, they are documented as <code class="language-plaintext highlighter-rouge">left</code>, <code class="language-plaintext highlighter-rouge">right</code>, <code class="language-plaintext highlighter-rouge">bottom</code>, <code class="language-plaintext highlighter-rouge">top</code>, <code class="language-plaintext highlighter-rouge">zNear</code>, <code class="language-plaintext highlighter-rouge">zFar</code>. The first four values define the dimensions of your camera’s view frustum. This basically means that any objects in your scene that are between these values will be seen by the camera. As you can see I chose the values 0, 1920, 0, 1080 for an HD projection. This means that any Game Object that is in my scene that’s x-value is between 0-1920 and y-value between 0-1080 will show up in my camera. The <code class="language-plaintext highlighter-rouge">zNear</code> and <code class="language-plaintext highlighter-rouge">zFar</code> values are used for the same thing as the perspective function.</p> <h2 id="the-view-matrix">The View Matrix</h2> <p>The next thing we need, is a view matrix. The view matrix is literally just the position of the camera in world space, and the direction it is pointing. This is important, because we need both to be able to find out what objects we need to render. Let’s look at some code that is typically used to set this up.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Vector3f</span> <span class="n">cameraForward</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="nc">Vector3f</span> <span class="n">cameraRight</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="nc">Vector3f</span> <span class="n">cameraUp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

<span class="c1">// Position would be defined somewhere else, it is simply</span>
<span class="c1">// the position of the camera in world space</span>
<span class="nc">Vector3f</span> <span class="n">center</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(</span><span class="n">position</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">position</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="n">position</span><span class="o">.</span><span class="na">z</span><span class="o">);</span>
<span class="n">center</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cameraForward</span><span class="o">);</span>

<span class="k">this</span><span class="o">.</span><span class="na">viewMatrix</span><span class="o">.</span><span class="na">identity</span><span class="o">();</span>
<span class="k">this</span><span class="o">.</span><span class="na">viewMatrix</span> <span class="o">=</span> <span class="n">viewMatrix</span><span class="o">.</span><span class="na">lookAt</span><span class="o">(</span><span class="n">transform</span><span class="o">.</span><span class="na">position</span><span class="o">,</span> <span class="n">center</span><span class="o">,</span> <span class="n">cameraUp</span><span class="o">);</span>
</code></pre></div></div> <p>As you can see in the code, I define three vectors for the <code class="language-plaintext highlighter-rouge">cameraForward</code>, <code class="language-plaintext highlighter-rouge">cameraRight</code>, and <code class="language-plaintext highlighter-rouge">cameraUp</code>. These are all unit vectors, meaning they all have a length of 1. This will help us to define the direction the camera is pointing in. Then, we have the center variable. This is a point in world space that the camera is looking towards. These are all required for JOML’s <code class="language-plaintext highlighter-rouge">lookAt</code> function that we use to create the view matrix. The documentation is listed <a href="https://joml-ci.github.io/JOML/apidocs/org/joml/Matrix4f.html#lookAt-org.joml.Vector3fc-org.joml.Vector3fc-org.joml.Vector3fc-">here</a>.</p> <p>The function takes three variables, the <code class="language-plaintext highlighter-rouge">eye</code>, <code class="language-plaintext highlighter-rouge">center</code> and <code class="language-plaintext highlighter-rouge">up</code>. These three vectors are used to create the view matrix. The <code class="language-plaintext highlighter-rouge">eye</code> is the camera’s position, the <code class="language-plaintext highlighter-rouge">center</code> is a point that the camera is looking towards, and <code class="language-plaintext highlighter-rouge">up</code> is what direction the top of the camera is facing. Let’s see what these look like visually.</p> <img src="/public/images/openGlCameras/visual2.png" alt="Camera Visualization 1"/> <p>In the image, we can clearly see that the center is just some point that is directly in front of the camera, and the eye is the position, and so on and so forth. This means that if we change any of the vectors, we will change the entire direction of the camera. Lets try an example, if we change the camera’s up vector from the current vector to: <code class="language-plaintext highlighter-rouge">cameraUp = new Vector3f(1, 0, 0);</code> the resulting configuration of our camera will look like this:</p> <img src="/public/images/openGlCameras/visual3.png" alt="Camera Visualization 2"/> <p>Now we have our camera facing an entirely different direction, all by changing one simple vector! In reality, you would also have to change your eye vector, and center vector to match the new configuration of the camera. By the way, this view matrix will work for 2D orthographic projections as well. Typically, in a 2D scenario, you would want a fixed view matrix for your camera, where the camera is pointed towards the xy plane as the first picture shows. Then, you can draw all your sprites on the xy plane, and the camera will always be pointing towards the correct direction.</p> <h2 id="conclusion">Conclusion</h2> <p>I hope this article gave you a good high-level overview of how cameras work in OpenGL. If you want a more concrete implementation of a camera, I highly recommend this <a href="https://learnopengl.com/Getting-started/Camera">article</a>. It is in C++, but the concepts are showed extrordinarily well. If you have any questions or comments, feel free to leave them below!</p> <p>Thanks for reading!</p> </div> <div class="related"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <h3> <a href="/games/2021/10/07/the-math-behind-font-rasterization/"> The Math Behind Font Rasterization <small>07 Oct 2021</small> </a> </h3> </li> <li> <h3> <a href="/games/2019/12/01/setting-up-dedicated-terraria-server/"> How to Make a Dedicated Terraria Server on Windows 10 <small>01 Dec 2019</small> </a> </h3> </li> <li> <h3> <a href="/music/2018/09/21/how-to-sight-read/"> 5 Steps to Learn How to Sight-Read Music <small>21 Sep 2018</small> </a> </h3> </li> </ul> </div> </div> </body> <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true
      },
      "HTML-CSS": { linebreaks: { automatic: true } },
      SVG: { linebreaks: { automatic: true } }
    });
  </script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> </html>